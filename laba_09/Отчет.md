# Лабораторная работа №09
# Динамическое программирование

**Дата:** 2025-04-12  
**Семестр:** 3 курс, 2 полугодие — 6 семестр  
**Группа:** ПИЖ-б-о-23-2  
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Силина Оксана Романовна 

---

## Цель работы
Изучить метод динамического программирования (ДП) как мощный инструмент для решения сложных задач путём их разбиения на перекрывающиеся подзадачи. Освоить два основных подхода к реализации ДП: нисходящий (с мемоизацией) и восходящий (с заполнением таблицы). Получить практические навыки выявления оптимальной подструктуры задач, построения таблиц ДП и анализа временной и пространственной сложности алгоритмов.

## Теоретическая часть

### Основные принципы ДП:
1. **Оптимальная подструктура:** Оптимальное решение задачи может быть построено из оптимальных решений её подзадач.
2. **Перекрывающиеся подзадачи:** Подзадачи, решения которых используются многократно, а не один раз.

### Подходы к реализации:
- **Нисходящее ДП (Top-Down, с мемоизацией):** Рекурсивное решение с сохранением (кэшированием) результатов решения подзадач для повторных вычислений.
- **Восходящее ДП (Bottom-Up, табличное):** Итеративное решение, при котором подзадачи решаются от простейших к сложным, а их результаты заносятся в таблицу (массив).

### Классические задачи:
1. Числа Фибоначчи
2. Задача о рюкзаке (0-1 Knapsack)
3. Наибольшая общая подпоследовательность (LCS)
4. Расстояние Левенштейна

---

## Реализация и Сложность

### 1. Числа Фибоначчи
- **Наивная рекурсия:** `O(2ⁿ)` — экспоненциальная сложность
- **Мемоизация (Top-Down):** `O(n)` — линейная сложность
- **Табличный подход (Bottom-Up):** `O(n)` — линейная сложность, оптимизация памяти до `O(1)`

### 2. Рюкзак 0-1 (Knapsack)
- **Метод:** Таблица `dp[n+1][W+1]`
- **Формула:** `dp[i][w] = max(dp[i-1][w], value + dp[i-1][w-weight])`
- **Сложность:** `O(n × W)` — псевдополиномиальная сложность
- **Восстановление решения:** Возможность определить, какие предметы были выбраны

### 3. Наибольшая общая подпоследовательность (LCS)
- **Метод:** Таблица `dp[len1+1][len2+1]`
- **Формула:** 
  ```
  если символы равны: dp[i][j] = dp[i-1][j-1] + 1
  иначе: dp[i][j] = max(dp[i-1][j], dp[i][j-1])
  ```
- **Сложность:** `O(n × m)`
- **Восстановление решения:** Возможность получить саму подпоследовательность

### 4. Расстояние Левенштейна
- **Метод:** Таблица операций вставки, удаления, замены
- **Формула:** `min(удаление, вставка, замена)`
- **Сложность:** `O(n × m)`

---

## Практическая реализация и тестирование

### 1. Сравнение подходов для чисел Фибоначчи

```
Сравнение подходов ДП
n       Наивная Мемоизация      Табличный
----------------------------------------
30      0.177442        0.000018        0.000005
35      2.159145        0.000021        0.000005
```

**Анализ результатов:**
- Наивная рекурсия уже при n=35 занимает более 2 секунд (2.159145 с)
- Метод мемоизации работает в ~100,000 раз быстрее (0.000021 с)
- Табличный подход самый быстрый (0.000005 с)
- Разница между мемоизацией и табличным подходом минимальна для небольших n, но табличный подход не использует рекурсивный стек

### 2. Задача о рюкзаке 0-1

```
Задача о рюкзаке:
Веса: [2, 3, 4, 5]
Стоимости: [3, 4, 5, 6]
Вместимость: 5
ДП (0-1): 7
Жадный (непрерывный): 7.00
```

**Анализ результатов:**
- Для данного набора данных оба алгоритма дали одинаковый результат (7)
- ДП-решение нашло оптимальный набор: предметы весом 2 и 3 со стоимостью 3+4=7
- Жадный алгоритм для непрерывного рюкзака также дал стоимость 7
- **Важное отличие:** ДП работает для дискретного рюкзака (предметы нельзя дробить), а жадный — для непрерывного

### 3. Размен монет

```
Размен 11 монетами [1, 2, 5]: 3
```

**Решение:** 5 + 5 + 1 = 11 (3 монеты)
**Алгоритм:** ДП-таблица размером amount+1, каждая ячейка хранит минимальное количество монет для данной суммы

### 4. Наибольшая возрастающая подпоследовательность (LIS)

```
LIS для [10, 9, 2, 5, 3, 7, 101, 18]: 
длина=4, последовательность=[2, 5, 7, 101]
```

**Анализ:**
- Найдена возрастающая подпоследовательность максимальной длины
- Алгоритм: `O(n²)` с восстановлением пути через массив prev

### 5. Наибольшая общая подпоследовательность (LCS)

```
LCS для 'AGGTAB' и 'GXTXAYB':
Длина LCS: 4
LCS: GTAB
```

**Визуализация таблицы:**
```
   ∅ G  X  T  X  A  Y  B 
∅   0  0  0  0  0  0  0  0
A   0  0  0  0  0  1  1  1
G   0  1  1  1  1  1  1  1
G   0  1  1  1  1  1  1  1
T   0  1  1  2  2  2  2  2
A   0  1  1  2  2  3  3  3
B   0  1  1  2  2  3  3  4
```

**Анализ:**
- Таблица наглядно показывает процесс заполнения
- Правый нижний угол содержит длину LCS (4)
- Восстановление последовательности идет от `dp[6][7]` к `dp[0][0]`

---

## Выводы и анализ эффективности

### 1. Временная сложность
| Алгоритм | Наивный подход | ДП-подход | Ускорение |
|----------|----------------|-----------|-----------|
| Фибоначчи | O(2ⁿ) | O(n) | Экспоненциальное |
| Рюкзак 0-1 | O(2ⁿ) | O(n×W) | Экспоненциальное |
| LCS | O(2ⁿ×m) | O(n×m) | Экспоненциальное |

### 2. Практические наблюдения
- **Мемоизация vs Табличный подход:**
  - Мемоизация проще в реализации (рекурсия + кэш)
  - Табличный подход обычно быстрее и использует меньше памяти стека
  - Для очень глубокой рекурсии табличный подход предпочтительнее

- **Восстановление решения:**
  - Все основные алгоритмы поддерживают восстановление решения
  - Для рюкзака можно узнать, какие предметы взяты
  - Для LCS можно получить саму подпоследовательность

### 3. Ограничения ДП
- **Проблема памяти:** Для больших n и W таблицы могут занимать много памяти
- **Псевдополиномиальная сложность:** Рюкзак 0-1 имеет сложность O(n×W), что при больших W становится неприемлемым

---

## Контрольные вопросы

### 1. Какие два основных свойства задачи указывают на то, что для ее решения можно применить динамическое программирование?
**Ответ:**
1. **Оптимальная подструктура** — оптимальное решение задачи может быть построено из оптимальных решений её подзадач.
2. **Перекрывающиеся подзадачи** — подзадачи, решения которых используются многократно, а не один раз.

### 2. В чем разница между нисходящим (top-down) и восходящим (bottom-up) подходами в динамическом программировании?
**Ответ:**
- **Нисходящий (Top-Down, мемоизация):** 
  - Решение начинается с основной задачи
  - Используется рекурсия с запоминанием результатов
  - Вычисляются только необходимые подзадачи
  - Может использовать много памяти стека
  
- **Восходящий (Bottom-Up, табличный):**
  - Решение начинается с простейших подзадач
  - Используется итеративное заполнение таблицы
  - Вычисляются все подзадачи
  - Обычно эффективнее по памяти и времени

### 3. Как задача о рюкзаке 0-1 демонстрирует свойство оптимальной подструктуры?
**Ответ:** Оптимальное решение для рюкзака вместимостью W с n предметами может быть построено из оптимальных решений для:
1. Рюкзака вместимостью W с n-1 предметами (если не берем n-й предмет)
2. Рюкзака вместимостью W-weight[n] с n-1 предметами плюс стоимость n-го предмета (если берем n-й предмет)

### 4. Опишите, как строится и заполняется таблица для решения задачи о наибольшей общей подпоследовательности (LCS).
**Ответ:**
1. Создается таблица размером (len(str1)+1) × (len(str2)+1)
2. Нулевые строки и столбцы заполняются нулями
3. Для каждой ячейки [i][j]:
   - Если символы равны: `dp[i][j] = dp[i-1][j-1] + 1`
   - Иначе: `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
4. Значение в правом нижнем углу — длина LCS

### 5. Как с помощью динамического программирования можно уменьшить сложность вычисления чисел Фибоначчи с экспоненциальной до линейной или даже до O(log n)?
**Ответ:**
- **Линейная сложность O(n):** Использовать мемоизацию или табличный подход
- **Логарифмическая сложность O(log n):** Использовать возведение матрицы [[1,1],[1,0]] в степень n с помощью быстрого возведения в степень

---

## Заключение

В ходе лабораторной работы были успешно реализованы классические алгоритмы динамического программирования. Экспериментально подтверждено преимущество ДП-подходов над наивной рекурсией (ускорение в сотни тысяч раз для чисел Фибоначчи). Реализованы оба подхода (мемоизация и табличный), проведено их сравнение. Все алгоритмы поддерживают восстановление решения. Код соответствует стандарту PEP8 и полностью документирован.